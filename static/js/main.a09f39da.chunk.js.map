{"version":3,"sources":["editor/IntentSystem.module.css","editor/types.ts","editor/utils.tsx","editor/AbstractNode.ts","editor/AbstractBaseEvent.ts","editor/AbstractHelper.ts","editor/AbstractEvent.ts","editor/AbstractSelection.ts","editor/hotkeys.ts","editor/IntentSystem.tsx","editor/docs/EditorDocument.tsx","editor/docs/hooks.tsx","editor/docs/Doc.tsx","editor/docs/Paragraph.tsx","editor/docs/Text.tsx","editor/defaultConfigs.tsx","editor/DocViews.tsx","editor/docs/ListItem.tsx","editor/Editor.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","DocType","AbstractEventType","AbstractPosition","randomId","Math","random","toString","substr","findAbstractNodeFromDOM","node","finder","p","result","undefined","parentElement","findTargetFromDOM","__ABSTRACT__","assert","condition","msg","Error","findAbstractNode","target","parent","getAbstractNodePath","from","to","path","push","reverse","compareAbstractPosition","node1","node2","Same","path1","path2","Disconnected","minLength","min","length","i","n1","n2","abstractNodes","indexOf","Following","Preceding","ContainedBy","Contains","pick","object","keys","withoutUndefined","ret","key","value","abstractUpdate","writableNode","nextData","finalNextData","data","partial","origin","all","Object","is","keysA","keysB","prototype","hasOwnProperty","call","isPartialShallowEqual","render","traverseAbstractNodes","captureCallback","event","arg1","arg2","boundary1","Array","isArray","boundary2","finalBoundary1","finalBoundary2","position","forward","traverseAbstractNodesRecursively","depth","start","end","currentIndex","index","leftEdge","rightEdge","nextDepth","propagating","bailed","lastIndexOf","leftIndex","rightIndex","leftChildIndex","rightChildIndex","bubbleCallback","leftEdgeIndex","rightEdgeIndex","SelectorResult","AbstractBaseEvent","root","range","initiator","originEvent","trace","returnValue","this","AbstractEvent","rawEvent","configs","type","payload","context","alwaySuccessSelector","Succuss","docTypeSelector","docTypes","some","docType","Fail","transformToSelector","arg0","args","selector","Bail","bail","defaultCreateCaptureCallback","interestHooks","hook","browserHook","bubble1","bubble2","state","AbstractHelper","current","_parent","_index","strict","sync","point1","point2","createCaptureCallback","entries","hooks","browserHooks","abstractEvent","question","emptyAbstractHelper","assertion","prepare","candidate","$","abstractNode","window","AbstractPoint","offset","AbstractRange","anchor","focus","collapsed","isForward","equals","range1","range2","AbstractSelection","helper","shift","step","newRange","dispatchEvent","SelectionMove","updateRange","preventDefault","moveSelection","windowSelection","getSelection","renderWindowSelection","selection","SelectionRendering","anchorNode","anchorOffset","focusNode","focusOffset","collapse","extend","removeAllRanges","isCollapsed","anchorAbstractNode","focusAbstractNode","SelectionSynchronize","Is_Apple","navigator","test","userAgent","GenericHotKeys","Bold","Compose","MoveBackward","MoveForward","MoveWordBackward","MoveWordForward","DeleteBackward","DeleteForward","ExtendBackward","ExtendForward","Italic","SplitBlock","Undo","Apple_HotKeys","MoveLineBackward","MoveLineForward","DeleteLineBackward","DeleteLineForward","DeleteWordBackward","DeleteWordForward","ExtendLineBackward","ExtendLineForward","Redo","TransposeCharacter","Windows_HotKeys","create","generic","apple","windows","isGeneric","isKeyHotkey","isApple","isWindows","isBold","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isExtendBackward","isExtendForward","isItalic","isSplitBlock","parentContext","currentContext","Context","replace","sliceNodes","replaced","deleteCount","items","renderAbstractNodes","every","item","nextAbstractNodes","slice","splice","abstractSplice","IntentSystem","abstractSelection","sel","nativeEvent","console","log","backward","formatBold","formatItalic","TextQueryStyle","boldBool","fontWeight","italicBool","fontStyle","left","right","leftNode","prevSibling","rightNode","nextSibling","style","excludes","nextRange","TextFormatStyle","Promise","resolve","then","deleteForward","deleteRange","abstractRange","ContentReplace","TextEnter","metaKey","keyCode","synchronizeWindowSelection","UserIntention","editable","children","useMemo","intentSystem","nextKeyDown","bind","nextKeyUp","nextSelectionChange","useIntentSystem","useEffect","document","addEventListener","removeEventListener","className","styles","spellCheck","tabIndex","contentEditable","suppressContentEditableWarning","onKeyDown","onKeyUp","EmptyDocConfig","View","documentContext","createContext","Doc","List","ListItem","Paragraph","Text","EditorDocument","RootView","Provider","id","useConnectAbstractNode","ref","useRef","useLayoutEffect","useNextDocViews","docConfigs","useContext","useState","setAbstractNodes","map","useAbstractNodeData","setData","DocConfig","anchorPoint","focusPoint","paragraphConfig","views","textAlign","align","createAbstractText","isSameStyleText","style1","style2","color","fontFamily","fontSize","textDecoration","_TextView","content","viewData","useViewState","pushText","absText","lastNode","peek","prev","displayName","TextConfig","React","memo","finalFocus","point","SelectionTryMove","remain","finalAnchor","max","stopPropagation","anchorBool","focusBool","spliceStart","spliceEnd","willFocus","array","nextContent","join","requireClean","leftContent","rightContent","_anchor","_focus","formatContent","formatedText","rightText","p1","p2","leftPoint","rightPoint","textNode","firstChild","defaultEditorConfigs","nodes","setNodes","order","display","flexDirection","alignItems","userSelect","paddingRight","text1","text2","text3","texts","query","URLSearchParams","location","search","len","get","_log","paragraph","defaultAbstractNode","Editor","linkAbstractNode","App","editor","setEditor","setTimeout","Boolean","hostname","match","ReactDOM","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a09f39da.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"editable\":\"IntentSystem_editable__3bj95\"};","import { CSSProperties } from \"react\";\nimport { AbstractNode, AnyAbstractNode } from \"./AbstractNode\";\nimport { AbstractEvent } from \"./AbstractEvent\";\nimport { AbstractBaseEvent } from \"./AbstractBaseEvent\";\nimport { AbstractRange } from \"./AbstractSelection\";\n\nexport enum DocType {\n  Doc,\n  List,\n  ListItem,\n  Paragraph,\n  Text,\n}\n\nexport type Align = 'left' | 'center' | 'right';\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\n// export interface IDocNode {\n//   type: Partial<DocType>;\n//   id: string;\n//   childNodes?: IDocNode[];\n// }\n\n// export interface IDocText {\n//   type: DocType.Text;\n//   id: string;\n//   content: string;\n//   style?: {\n//     fontFamily?: CSSProperties['fontFamily'];\n//     fontStyle?: CSSProperties['fontStyle'];\n//     fontSize?: CSSProperties['fontSize'];\n//     color?: CSSProperties['color'];\n//     fontWeight?: CSSProperties['fontWeight'];\n//     textDecoration?: CSSProperties['textDecoration'];\n//   };\n// }\n\n// export interface IDocParagraph {\n//   type: DocType.Paragraph;\n//   id: string;\n//   childNodes: NonEmptyArray<IDocText>;\n//   align?: Align;\n// }\n\n// export interface IDocListItem {\n//   type: DocType.ListItem,\n//   id: string;\n//   childNodes: NonEmptyArray<IDocParagraph>;\n//   order: string;\n// }\n\n// export interface IDocList {\n//   type: DocType.List;\n//   id: string;\n//   childNodes: NonEmptyArray<IDocParagraph | IDocList | IDocListItem>;\n//   orderList: boolean;\n// }\n\n// export interface IDoc {\n//   type: DocType.Doc;\n//   id: string;\n//   childNodes: NonEmptyArray<IDocParagraph | IDocList>;\n// }\n\nexport interface AbstractDoc extends AbstractNode<DocType.Doc, never> {\n  readonly abstractNodes: NonEmptyArray<AbstractList | AbstractParagraph>;\n}\n\nexport interface AbstractList extends AbstractNode<DocType.List> {\n  readonly data: {\n    orderList: boolean;\n  };\n  readonly abstractNodes: NonEmptyArray<AbstractListItem | AbstractParagraph>;\n}\n\nexport interface AbstractListItem extends AbstractNode<DocType.ListItem> {\n  readonly data: {\n    order: string;\n  };\n  readonly abstractNodes: NonEmptyArray<AbstractParagraph>;\n}\n\nexport interface AbstractParagraph extends AbstractNode<DocType.Paragraph> {\n  readonly data?: {\n    align: Align;\n  };\n  readonly abstractNodes: NonEmptyArray<AbstractText>;\n}\n\nexport interface AbstractText extends AbstractNode<DocType.Text> {\n  readonly data: {\n    content: string;\n    style?: {\n      fontFamily?: CSSProperties['fontFamily'];\n      fontStyle?: CSSProperties['fontStyle'];\n      fontSize?: CSSProperties['fontSize'];\n      color?: CSSProperties['color'];\n      fontWeight?: CSSProperties['fontWeight'];\n      textDecoration?: CSSProperties['textDecoration'];\n    };\n  };\n}\n\nexport enum AbstractEventType {\n  // Selection\n  SelectionSynchronize,\n  SelectionRendering,\n  SelectionMove,\n  SelectionTryMove,\n  SelectionBlur,\n\n  // Text\n  TextStyle,\n  TextDelete,\n  TextDeleteBackward,\n  ContentReplace,\n  TextEnter,\n  TextFormatStyle,\n  TextQueryStyle,\n\n  // Paragraph\n}\n\nexport interface SelectionSynchronizePayload {\n  isCollapsed: boolean;\n  anchorNode: Node;\n  anchorOffset: number;\n  focusNode: Node;\n  focusOffset: number;\n  anchorAbstractNode: AnyAbstractNode;\n  focusAbstractNode: AnyAbstractNode;\n}\n\nexport interface SelectionMovePayload {\n  forward: boolean;\n  shift: boolean;\n  step: number;\n}\n\nexport interface SelectionTryMovePayload {\n  step: number;\n  forward: boolean;\n}\n\nexport interface TextQueryStylePayload {\n  keys: (keyof NonNullable<AbstractText['data']['style']>)[];\n}\n\nexport interface RawAbstractEvent<T = any> {\n  type: AbstractEventType,\n  payload: T;\n}\n\nexport type AbstractHook = (this: any & { state: never }, abstractEvent: AbstractEvent) => void | BubbleCallback<any>;\n\nexport type AbstractHooks = {\n  [type in AbstractEventType]?: AbstractHook;\n}\n\nexport type AbstractBrowserHook = (this: any & { state: any }, abstractEvent: AbstractEvent) => void | BubbleCallback<any>;\n\nexport type AbstractBrowserHooks = {\n  [type in AbstractEventType]?: AbstractBrowserHook;\n}\n\nexport type AbstractConfigs = {\n  [docType in DocType]: {\n    hooks: AbstractHooks,\n    browserHooks: AbstractBrowserHooks,\n  };\n};\n\nexport type DocConfigs = {\n  [docType in DocType]: {\n    readonly View: React.FC<any>;\n  }\n};\n\nexport type EditorConfigs = AbstractConfigs & DocConfigs;\n\nexport type BubbleCallback<T> = (this: T) => void;\n\nexport type CaptureCallback<T extends AbstractBaseEvent, U> = (this: AnyAbstractNode, abstractEvent: T) => void | BubbleCallback<U>;\n\nexport enum AbstractPosition {\n  Disconnected,\n  Same,\n  Preceding,\n  Following,\n  Contains,\n  ContainedBy,\n}\n\nexport type Writable<T> = {\n  -readonly [K in keyof T]: T[K];\n};\n\nexport interface Reference<T, P = undefined> {\n  current: T | P;\n}\n","import { AbstractNode, AnyAbstractNode } from \"./AbstractNode\";\nimport { AbstractPosition } from \"./types\";\n\nexport function randomId() {\n  return Math.random().toString(36).substr(2);\n}\n\nexport type TargetFinder<T> = (node: Node) => void | T;\n\nexport function findTargetFromDOM<T>(node: Node, finder: TargetFinder<T>) {\n  let p: Node | null = node;\n  while (p) {\n    const result = finder(p);\n    if (result !== undefined) {\n      return result;\n    }\n    p = p.parentElement;\n  }\n  return undefined;\n}\n\nexport function findAbstractNodeFromDOM(node: Node) {\n  return findTargetFromDOM(\n    node,\n    node => '__ABSTRACT__' in node ? (node as any).__ABSTRACT__ as AnyAbstractNode : undefined,\n  );\n}\n\nexport function assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg || `assert: ${condition}`);\n  }\n}\n\nexport function findAbstractNode(node: AnyAbstractNode, target: AnyAbstractNode) {\n  let p: AnyAbstractNode | undefined = node;\n  while (p) {\n    if (p === target) {\n      return target;\n    }\n    p = p.parent;\n  }\n}\n\nexport function isPartialShallowEqual(partial: any, origin: any, all = false): boolean {\n  if (Object.is(partial, origin)) {\n    return true;\n  }\n\n  if (\n    typeof partial !== 'object' ||\n    partial === null ||\n    typeof origin !== 'object' ||\n    origin === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(partial);\n  const keysB = Object.keys(origin);\n\n  if (all && keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (const key of keysA) {\n    if (\n      !Object.prototype.hasOwnProperty.call(origin, key) ||\n      !Object.is(partial[key], origin[key])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n  \nexport function getAbstractNodePath(from: AnyAbstractNode, to?: AnyAbstractNode) {\n  const path: AnyAbstractNode[] = [];\n  let p: AnyAbstractNode | undefined = from;\n  while (p) {\n    path.push(p);\n    if (p === to) {\n      break;\n    }\n    p = p.parent;\n  }\n  return path.reverse();\n}\n\nexport function compareAbstractPosition(node1: AnyAbstractNode, node2: AnyAbstractNode): AbstractPosition {\n  if (node1 === node2) {\n    return AbstractPosition.Same;\n  }\n  const path1 = getAbstractNodePath(node1);\n  const path2 = getAbstractNodePath(node2);\n\n  if (path1[0] !== path2[0]) {\n    return AbstractPosition.Disconnected;\n  }\n\n  const minLength = Math.min(path1.length, path2.length);\n  for (let i = 0; i < minLength; i++) {\n    const n1 = path1[i];\n    const n2 = path2[i];\n    if (n1 !== n2) {\n      const { abstractNodes } = path1[i - 1];\n      assert(abstractNodes);\n      const index1 = abstractNodes.indexOf(n1);\n      const index2 = abstractNodes.indexOf(n2);\n      return index1 <= index2 ? AbstractPosition.Following : AbstractPosition.Preceding;\n    }\n  }\n  return path1.length <= path2.length ? AbstractPosition.ContainedBy : AbstractPosition.Contains;\n}\n\nexport function pick<T extends { [key: string]: any }>(object: T, keys: (keyof T)[], withoutUndefined = false) {\n  const ret: Partial<T> = {};\n  for (const key of keys) {\n    const value = object[key];\n    if (!withoutUndefined || value !== undefined) {\n      ret[key] = object[key];\n    }\n  }\n  return ret;\n}\n","import { DocType, CaptureCallback, BubbleCallback, Writable, NonEmptyArray, AbstractPosition } from \"./types\";\nimport { isPartialShallowEqual, assert, getAbstractNodePath, compareAbstractPosition } from \"./utils\";\nimport { AbstractEvent } from \"./AbstractEvent\";\nimport { AbstractBaseEvent } from \"./AbstractBaseEvent\";\n\nexport type AnyAbstractNode<K extends DocType = DocType> = AbstractNode<K>;\n\nexport interface AbstractNode<\n  K extends DocType,\n  T extends { [key: string]: any } = any,\n  P extends NonEmptyArray<AnyAbstractNode> = NonEmptyArray<AnyAbstractNode>,\n  U extends { [key: string]: any } = any,\n> {\n  readonly type: K;\n  readonly id: string;\n\n  readonly data?: T;\n  readonly abstractNodes?: P;\n\n  readonly parent?: AnyAbstractNode;\n\n  render?(data: T): void;\n  renderAbstractNodes?(abstractNodes?: P): void;\n\n  state?: U;\n\n  batch?: {\n    data?: T;\n    abstractNodes?: P;\n  };\n}\n\nexport function linkAbstractNode(root: AnyAbstractNode) {\n  const { abstractNodes } = root;\n  if (abstractNodes) {\n    for (const node of abstractNodes) {\n      (node as Writable<AnyAbstractNode>).parent = root;\n      linkAbstractNode(node);\n    }\n  }\n}\n\n// export function abstract<\n//   T extends AnyAbstractNode,\n// >(\n//   type: T['type'],\n//   id: string,\n//   data: T['data'],\n//   abstractNodes: T['abstractNodes'],\n//   parent?: AnyAbstractNode,\n//   render?: (data: T['data']) => void,\n//   renderAbstractNodes?: (children: T['abstractNodes']) => void,\n//   onViewHook?: (this: AbstractNode<T['type'], T>, abstractEvent: AbstractEvent, originEvent?: Event) => void,\n// ): T {\n//   return {\n//     type,\n//     id,\n//     data,\n//     abstractNodes,\n//     parent,\n//     render,\n//     renderAbstractNodes,\n//     onViewHook,\n//   } as T;\n// }\n\ntype NextData<T extends AbstractNode<DocType>> = T['data'] | ((prevData: T['data']) => T['data']) | undefined;\n\nexport function abstractUpdate<T extends AbstractNode<DocType>>(writableNode: Writable<T>, nextData: NextData<T>) {\n  const finalNextData = typeof nextData === 'function' ? nextData(writableNode.data) as T['data'] : nextData;\n  if (!isPartialShallowEqual(finalNextData, writableNode.data, true)) {\n    writableNode.data = finalNextData;\n    if (writableNode.render) {\n      writableNode.render(finalNextData);\n    }\n  }\n}\n\nexport function abstractSplice(node: Writable<AnyAbstractNode>, start: number, deleteCount: number, items: Writable<AnyAbstractNode>[]) {\n  const { abstractNodes, renderAbstractNodes } = node;\n  assert(abstractNodes);\n\n  if (\n    deleteCount === items.length &&\n    items.every((item, index) => item === abstractNodes[start + index])\n  ) {\n    return;\n  }\n\n  const nextAbstractNodes = abstractNodes.slice() as typeof abstractNodes;\n  nextAbstractNodes.splice(start, deleteCount, ...items);\n  // for (const item of items) {\n  //   item.parent = node;\n  // }\n  node.abstractNodes = nextAbstractNodes.length ? nextAbstractNodes : undefined;\n\n  if (renderAbstractNodes) {\n    renderAbstractNodes(node.abstractNodes);\n  }\n}\n\n// export type AbstractData<T extends IDocNode> = Omit<T, 'type' | 'id' | 'childNodes'>;\n\n// export class AbstractNode<T extends IDocNode = any> {\n//   readonly type: DocType;\n//   readonly id: string;\n\n//   // render view\n//   data: AbstractData<T>;\n//   render?(data: AbstractData<T>): void;\n//   // render children\n//   abstractNodes?: AbstractNode[];\n//   renderAbstractNodes?(abstractNodes?: AbstractNode[]): void;\n\n//   // intent hook\n//   onViewIntent?(abstractIntent: AbstractIntent, originEvent?: Event): void | BubbleCallback;\n\n//   constructor(\n//     { type, id, childNodes, ...rest }: IDocNode,\n//     public parent: AbstractNode | null,\n//   ) {\n//     this.type = type;\n//     this.id = id;\n//     this.data = rest as any;\n//     this.abstractNodes = childNodes?.map(node => new AbstractNode(node, this));\n//   }\n\n//   update(partialData: Partial<AbstractData<T>>) {\n//     if (isPartialShallowEqual(partialData, this.data)) {\n//       return;\n//     }\n//     this.data = Object.assign({}, this.data, partialData);\n//     if (this.render) {\n//       this.render(this.data);\n//     }\n//   }\n\n//   concat(...items: AbstractNode[]): AbstractNode[] {\n//     if (items.length) {\n//       this.abstractNodes = this.abstractNodes ? this.abstractNodes.concat(...items) : items;\n//       if (this.renderAbstractNodes) {\n//         this.renderAbstractNodes(this.abstractNodes);\n//       }\n//     }\n//     return this.abstractNodes || [];\n//   }\n\n//   indexOf(searchElement: AbstractNode): number {\n//     return this.abstractNodes ? this.abstractNodes.indexOf(searchElement) : -1;\n//   }\n\n//   splice(start: number, deleteCount?: number): AbstractNode[];\n//   splice(start: number, deleteCount: number, ...items: AbstractNode[]): AbstractNode[];\n//   splice(start: number, deleteCount?: number, ...items: AbstractNode[]): AbstractNode[] {\n//     assert(this.abstractNodes);\n//     let ret: AbstractNode[];\n//     this.abstractNodes = this.abstractNodes.slice();\n//     if (deleteCount == null) {\n//       ret = this.abstractNodes.splice(start);\n//     } else {\n//       ret = this.abstractNodes.splice(start, deleteCount, ...items);\n//     }\n\n//     if (this.renderAbstractNodes) {\n//       this.renderAbstractNodes(this.abstractNodes);\n//     }\n//     return ret;\n//   }\n\n//   /**\n//    * [   a   b   c   d   e   ]\n//    * \n//    * ### example 1\n//    * replace: [a] -> [X]\n//    * replace([X], a, a)\n//    * \n//    * ### example 2\n//    * replace: [b, c, d] -> [X1, X2]\n//    * replace([X1, X2], b, d)\n//    * \n//    * ### example 2\n//    * replace: [b, c, d, e] -> [X1, X2]\n//    * replace([X1, X2], b, e)\n//    */\n//   replace(candidates: AbstractNode[], from: AbstractNode, to: AbstractNode): AbstractNode[] {\n//     assert(this.abstractNodes);\n//     let fromIndex = this.abstractNodes.indexOf(from);\n//     let toIndex = from === to ? fromIndex : this.abstractNodes.indexOf(to);\n\n//     if (toIndex < fromIndex) {\n//       [fromIndex, toIndex] = [toIndex, fromIndex];\n//     }\n//     assert(fromIndex !== -1 && toIndex !== -1);\n\n//     const copy = this.abstractNodes.slice();\n//     const ret = copy.splice(fromIndex, toIndex - fromIndex + 1, ...candidates);\n\n//     this.abstractNodes = copy.length ? copy : undefined;\n//     if (this.renderAbstractNodes) {\n//       this.renderAbstractNodes(this.abstractNodes);\n//     }\n//     return ret;\n//   }\n\n//   detach() {\n//     assert(this.parent);\n//     this.parent.replace([], this, this);\n//   }\n// }\n\nexport function traverseAbstractNodesRecursively<T extends AbstractBaseEvent>(\n  captureCallback: CaptureCallback<T, AnyAbstractNode>,\n  event: T,\n  node: AnyAbstractNode,\n  forward: boolean,\n  depth: number,\n  boundary1?: AnyAbstractNode[],\n  boundary2?: AnyAbstractNode[],\n) {\n  event.depth = depth;\n  const currentIndex = event.index;\n  const { abstractNodes } = node;\n\n  const { leftEdge, rightEdge } = event;\n\n  let start: number | undefined;\n  let end: number | undefined;\n  const nextDepth = depth + 1;\n\n  if (event.propagating && !event.bailed && abstractNodes) {\n    const node1 = boundary1 && nextDepth < boundary1.length && boundary1[nextDepth];\n    const node2 = boundary2 && nextDepth < boundary2.length && boundary2[nextDepth];\n\n    start = node1\n      ? abstractNodes.indexOf(node1)\n      : forward ? 0 : abstractNodes.length - 1;\n    assert(start !== -1);\n\n    end = node2\n      ? (forward ? abstractNodes.indexOf(node2, start) : abstractNodes.lastIndexOf(node2, start))\n      : (forward ? abstractNodes.length - 1 : 0);\n    assert(end !== -1);\n\n    assert(forward ? start <= end : end <= start);\n  }\n\n  event.leftEdge = leftEdge;\n  event.rightEdge = rightEdge;\n  const leftIndex = forward ? start : end;\n  const rightIndex = forward ? end : start;\n  event.leftChildIndex = leftIndex;\n  event.rightChildIndex = rightIndex;\n  const bubbleCallback = captureCallback.call(node, event);\n\n  if (start !== undefined && end !== undefined) {\n    assert(abstractNodes);\n    const leftEdgeIndex = event.leftEdge && (forward ? start : end);\n    const rightEdgeIndex = event.rightEdge && (forward ? end : start);\n\n    for (\n      let i = start;\n      !event.bailed && (forward ? i <= end : i >= end);\n      i = forward ? i + 1 : i - 1\n    ) {\n      assert(abstractNodes[i].parent);\n      event.index = i;\n      if (i === leftEdgeIndex) {\n        event.leftEdge = true;\n      } else if (event.leftEdge) {\n        event.leftEdge = false;\n      }\n      if (i === rightEdgeIndex) {\n        event.leftEdge = true;\n      } else if (event.rightEdge) {\n        event.rightEdge = false;\n      }\n\n      traverseAbstractNodesRecursively(\n        captureCallback,\n        event,\n        abstractNodes[i],\n        forward,\n        nextDepth,\n        i === start ? boundary1 : undefined,\n        i === end ? boundary2 : undefined,\n      );\n    }\n  }\n\n  event.leftChildIndex = leftIndex;\n  event.rightChildIndex = rightIndex;\n  event.depth = depth;\n  event.index = currentIndex;\n  if (bubbleCallback) {\n    bubbleCallback.call(node);\n  }\n  event.propagating = true;\n}\n\nexport function traverseAbstractNodes<T extends AbstractBaseEvent = AbstractBaseEvent>(\n  captureCallback: CaptureCallback<T, AnyAbstractNode>,\n  origin: AnyAbstractNode,\n  event: T,\n  arg1?: AnyAbstractNode[] | AnyAbstractNode,\n  arg2?: AnyAbstractNode[] | AnyAbstractNode,\n) {\n  const boundary1 = Array.isArray(arg1) ? arg1 : arg1 && getAbstractNodePath(arg1, origin);\n  const boundary2 = arg1 === arg2 ? boundary1 : (\n    Array.isArray(arg2) ? arg2 : arg2 && getAbstractNodePath(arg2, origin)\n  );\n  assert(!boundary1 || boundary1[0] === origin);\n  assert(!boundary2 || boundary2[0] === origin);\n\n  let finalBoundary1 = boundary1;\n  let finalBoundary2 = boundary2;\n  if (boundary1 && boundary2) {\n    const position = compareAbstractPosition(\n      boundary1[boundary1.length - 1],\n      boundary2[boundary2.length - 1],\n    );\n    if (\n      (position === AbstractPosition.Following && !event.forward) ||\n      (position === AbstractPosition.Preceding && event.forward)\n    ) {\n      [finalBoundary2, finalBoundary1] = [finalBoundary1, finalBoundary2];\n    }\n  }\n  event.boundary1 = finalBoundary1;\n  event.boundary2 = finalBoundary2;\n\n  traverseAbstractNodesRecursively(\n    captureCallback,\n    event,\n    origin,\n    event.forward,\n    0,\n    finalBoundary1,\n    finalBoundary2,\n  );\n}\n","import { AnyAbstractNode } from \"./AbstractNode\";\nimport { AbstractRange } from \"./AbstractSelection\";\n\nexport class AbstractBaseEvent<T = any, R = any, E = Event | undefined> {\n  propagating = true;\n  bailed = false;\n  depth = -1;\n  /**\n   * -2: lazy calculate\n   * -1: no parent\n   * >= 0: index in parent.abstractNodes\n   */\n  index = -2;\n  boundary1?: AnyAbstractNode[];\n  boundary2?: AnyAbstractNode[];\n\n  leftEdge = true;\n  rightEdge = true;\n\n  trace?: T;\n  returnValue?: R;\n\n  leftChildIndex?: number;\n  rightChildIndex?: number;\n\n  constructor(\n    public readonly root: AnyAbstractNode,\n    public readonly forward: boolean,\n    public readonly range?: AbstractRange | null,\n    public readonly initiator?: AnyAbstractNode,\n    public readonly originEvent?: E,\n  ) {}\n\n  stopPropagation() {\n    this.propagating = false;\n  }\n\n  bail() {\n    this.bailed = true;\n  }\n}\n","import { RawAbstractEvent, DocType, AbstractConfigs, AbstractHook, AbstractBrowserHook, AbstractEventType, CaptureCallback } from \"./types\";\nimport { AnyAbstractNode, traverseAbstractNodes, AbstractNode } from \"./AbstractNode\";\nimport { AbstractBaseEvent } from './AbstractBaseEvent';\nimport { assert } from \"./utils\";\nimport { AbstractEvent } from \"./AbstractEvent\";\nimport { AbstractRange } from \"./AbstractSelection\";\n\nexport enum SelectorResult {\n  Bail = -1,\n  Fail = 0,\n  Succuss = 1,\n}\n\ntype AbstractSelector = (node: AnyAbstractNode) => SelectorResult;\n\nfunction alwaySuccessSelector() {\n  return SelectorResult.Succuss;\n}\n\nfunction docTypeSelector(...docTypes: DocType[]) {\n  return function selector(node: AnyAbstractNode) {\n    if (docTypes.some(docType => docType === node.type)) {\n      return SelectorResult.Succuss;\n    }\n    return SelectorResult.Fail;\n  };\n}\n\nfunction transformToSelector(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractSelector {\n  if (arg0 == null) {\n    return alwaySuccessSelector;\n  }\n  if (typeof arg0 === 'function') {\n    return arg0;\n  }\n  return docTypeSelector(arg0, ...args);\n}\n\nfunction findAbstractNode(\n  node: AnyAbstractNode,\n  selector: AbstractSelector,\n  forward: boolean,\n): { node: AnyAbstractNode, index: number } | null {\n  let ret: { node: AnyAbstractNode, index: number } | null = null;\n  function captureCallback(this: AnyAbstractNode, event: AbstractBaseEvent) {\n    switch (selector(this)) {\n      case SelectorResult.Succuss:\n        ret = { node: this, index: event.index };\n      case SelectorResult.Bail:\n        event.bail();\n    }\n  }\n  traverseAbstractNodes(captureCallback, node, new AbstractBaseEvent(node, forward));\n  return ret;\n}\n\n// function iterateAbstractNode(node: AnyAbstractNode, start: number, forward: boolean) {\n// }\n\nexport interface IntentDetails {\n  initiator?: AnyAbstractNode;\n  range?: AbstractRange | null;\n  forward: boolean;\n  configs: AbstractConfigs;\n  originEvent?: any;\n\n  point1?: AnyAbstractNode;\n  point2?: AnyAbstractNode;\n  boundary1?: AnyAbstractNode[];\n  boundary2?: AnyAbstractNode[];\n\n  createCaptureCallback?(this: AnyAbstractNode, interestHooks: any): CaptureCallback<AbstractEvent, AnyAbstractNode>;\n}\n\nfunction defaultCreateCaptureCallback(interestHooks: any) {\n  return function captureCallback(this: AnyAbstractNode, event: AbstractEvent) {\n    const value = interestHooks[this.type]\n    if (value) {\n      const { hook, browserHook } = value;\n      const bubble1 = hook && hook.call(this, event);\n      const bubble2 = browserHook && browserHook.call(this, event, this.state);\n      return bubble1 && bubble2 ? function bubbleCallback() {\n        bubble2();\n        bubble1();\n      } : bubble1 || bubble2 || undefined;\n    }\n  };\n}\n\nexport class AbstractHelper {\n  private _parent: AnyAbstractNode | null = null;\n\n  constructor(\n    readonly current: AnyAbstractNode | null,\n    private index: number = -1,\n  ) {\n    const _parent = current?.parent || null;\n    this._parent = _parent;\n    assert(index >= -1);\n    if (index !== -1) {\n      assert(\n        _parent &&\n        _parent.abstractNodes &&\n        index < _parent.abstractNodes.length &&\n        this.current === _parent.abstractNodes[index]\n      );\n    }\n  }\n\n  private sync() {\n    this._parent = this.current?.parent || null;\n    const { _parent, index: _index, current } = this;\n    if (_parent) {\n      assert(current && _parent.abstractNodes);\n      if (_parent.abstractNodes[_index] !== current) {\n        this.index = _parent.abstractNodes.indexOf(current);\n        assert(this.index !== -1);\n      }\n    } else {\n      this.index = -1;\n    }\n  }\n\n  private prepare(strict: boolean, arg0?: AbstractSelector | DocType, ...args: DocType[]) {\n    const selector = transformToSelector(arg0, ...args);\n    if (strict) {\n      this.sync();\n    }\n    return selector;\n  }\n\n  dispatchEvent<T, P = any>(\n    rawEvent: RawAbstractEvent<P>,\n    { initiator, range, forward, point1, point2, boundary1, boundary2, configs, originEvent, createCaptureCallback }: IntentDetails,\n  ): T | undefined {\n    const { current } = this;\n    if (!current) {\n      return undefined;\n    }\n\n    const interestHooks: any = {};\n    for (const [key, { hooks, browserHooks }] of Object.entries(configs)) {\n      const hook = hooks[rawEvent.type];\n      const browserHook = browserHooks[rawEvent.type];\n      if (hook || browserHook) {\n        interestHooks[key] = { hook, browserHook };\n      }\n    }\n    const captureCallback = (createCaptureCallback || defaultCreateCaptureCallback)(interestHooks);\n\n    const abstractEvent = new AbstractEvent<P, T>(current, rawEvent, forward, configs, range, initiator, originEvent);\n\n    traverseAbstractNodes(captureCallback, current, abstractEvent, boundary1 || point1, boundary2 || point2);\n    return abstractEvent.returnValue;\n  }\n\n  is(question: (node: AnyAbstractNode | null) => boolean): AbstractHelper {\n    return question(this.current) ? this : emptyAbstractHelper;\n  }\n\n  assert(assertion: (node: AnyAbstractNode | null) => boolean): AbstractHelper {\n    assert(assertion(this.current));\n    return this;\n  }\n\n  parent(...docTypes: DocType[]): AbstractHelper;\n  parent(selector?: AbstractSelector): AbstractHelper;\n  parent(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    if (!this.current) {\n      return this;\n    }\n    const selector = this.prepare(true, arg0, ...args);\n    let p: AnyAbstractNode | undefined = this.current.parent;\n    let ret = emptyAbstractHelper;\n    while (p) {\n      if (selector(p)) {\n        ret = new AbstractHelper(p);\n        break;\n      }\n      p = p.parent;\n    }\n    return ret;\n  }\n\n  find(...docTypes: DocType[]): AbstractHelper;\n  find(selector?: AbstractSelector): AbstractHelper;\n  find(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    const selector = this.prepare(false, arg0, ...args);\n    const result = this.current && findAbstractNode(this.current, selector, true);\n    if (result) {\n      return new AbstractHelper(result.node, result.index);\n    }\n    return emptyAbstractHelper;\n  }\n\n  findBackward(...docTypes: DocType[]): AbstractHelper;\n  findBackward(selector?: AbstractSelector): AbstractHelper;\n  findBackward(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    const selector = this.prepare(false, arg0, ...args);\n    const result = this.current && findAbstractNode(this.current, selector, false);\n    if (result) {\n      return new AbstractHelper(result.node, result.index);\n    }\n    return emptyAbstractHelper;\n  }\n\n  nextSibling(...docTypes: DocType[]): AbstractHelper;\n  nextSibling(selector?: AbstractSelector): AbstractHelper;\n  nextSibling(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    const { current } = this;\n    if (!current) {\n      return this;\n    }\n    const selector = this.prepare(true, arg0, ...args);\n    const { _parent } = this;\n    if (_parent) {\n      assert(_parent.abstractNodes);\n      for (let i = this.index + 1; i < _parent.abstractNodes.length; i++) {\n        const candidate = _parent.abstractNodes[i];\n        if (selector(candidate)) {\n          return new AbstractHelper(candidate, i);\n        }\n      }\n    }\n    return emptyAbstractHelper;\n  }\n\n  prevSibling(...docTypes: DocType[]): AbstractHelper;\n  prevSibling(selector?: AbstractSelector): AbstractHelper;\n  prevSibling(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    const { current } = this;\n    if (!current) {\n      return this;\n    }\n    const selector = this.prepare(true, arg0, ...args);\n    const { _parent } = this;\n    if (_parent) {\n      assert(_parent.abstractNodes);\n      for (let i = this.index - 1; i >= 0; i++) {\n        const candidate = _parent.abstractNodes[i];\n        if (selector(candidate)) {\n          return new AbstractHelper(candidate, i);\n        }\n      }\n    }\n    return emptyAbstractHelper;\n  }\n\n  next(...docTypes: DocType[]): AbstractHelper;\n  next(selector?: AbstractSelector): AbstractHelper;\n  next(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    const { current, _parent } = this;\n    if (!current) {\n      return this;\n    }\n    const selector = this.prepare(true, arg0, ...args);\n    if (_parent) {\n      assert(_parent.abstractNodes);\n      for (let i = this.index + 1; i < _parent.abstractNodes.length; i++) {\n        const node = _parent.abstractNodes[i];\n        const result = findAbstractNode(node, selector, true);\n        if (result) {\n          return new AbstractHelper(result.node, result.index);\n        }\n      }\n    }\n    return emptyAbstractHelper;\n  }\n\n  prev(...docTypes: DocType[]): AbstractHelper;\n  prev(selector?: AbstractSelector): AbstractHelper;\n  prev(arg0?: AbstractSelector | DocType, ...args: DocType[]): AbstractHelper {\n    const { current, _parent } = this;\n    if (!current) {\n      return this;\n    }\n    if (_parent) {\n      const selector = this.prepare(true, arg0, ...args);\n      assert(_parent.abstractNodes);\n      for (let i = this.index - 1; i >= 0; i--) {\n        const node = _parent.abstractNodes[i];\n        const result = findAbstractNode(node, selector, false);\n        if (result) {\n          return new AbstractHelper(result.node, result.index);\n        }\n      }\n    }\n    return emptyAbstractHelper;\n  }\n\n  only(): AbstractHelper {\n    this.sync();\n    const { _parent } = this;\n    if (_parent && _parent.abstractNodes && _parent.abstractNodes.length === 1) {\n      return this;\n    }\n    return emptyAbstractHelper;\n  }\n\n  assertOnly(): AbstractHelper {\n    this.sync();\n    const { _parent } = this;\n    assert(_parent && _parent.abstractNodes && _parent.abstractNodes.length === 1);\n    return this;\n  }\n}\n\nconst emptyAbstractHelper = new AbstractHelper(null);\n\nexport function $(abstractNode: AnyAbstractNode | null, index?: number) {\n  return new AbstractHelper(abstractNode, index);\n}\n\n(window as any).$ = $;\n","import { AbstractEventType, DocType, RawAbstractEvent, AbstractConfigs } from \"./types\";\nimport { AbstractBaseEvent } from \"./AbstractBaseEvent\";\nimport { AbstractPoint, AbstractRange } from \"./AbstractSelection\";\nimport { AnyAbstractNode } from \"./AbstractNode\";\n\nexport type AbstractIntentTrace = {\n  [docType in DocType]?: { [key: string]: any };\n} & {\n  selection?: {\n    anchorPoint?: AbstractPoint,\n    focusPoint?: AbstractPoint,\n  },\n  windowSelection?: {\n    anchorNode?: Node,\n    anchorOffset?: number,\n    focusNode?: Node,\n    focusOffset?: number,\n  },\n};\n\nexport class AbstractEvent<P = any, R = any, E = any> extends AbstractBaseEvent<any, R, E> {\n  type: AbstractEventType;\n  payload: P;\n  trace: AbstractIntentTrace = {};\n  context?: any;\n\n  constructor(\n    root: AnyAbstractNode,\n    rawEvent: RawAbstractEvent,\n    forward: boolean,\n    public configs: AbstractConfigs,\n    range?: AbstractRange | null,\n    initiator?: AnyAbstractNode,\n    originEvent?: E,\n  ) {\n    super(root, forward, range, initiator, originEvent);\n    this.type = rawEvent.type;\n    this.payload = rawEvent.payload;\n  }\n}\n","import { AbstractNode, AnyAbstractNode } from \"./AbstractNode\";\nimport { assert, findAbstractNodeFromDOM, findAbstractNode, compareAbstractPosition } from \"./utils\";\nimport { AbstractConfigs, AbstractEventType, SelectionSynchronizePayload, AbstractPosition, SelectionMovePayload } from \"./types\";\nimport { AbstractHelper } from \"./AbstractHelper\";\nimport { AbstractIntentTrace } from \"./AbstractEvent\";\n\nexport class AbstractPoint {\n  constructor(\n    public readonly node: AnyAbstractNode,\n    public readonly offset: number,\n  ) {}\n\n  static equals(point1: AbstractPoint, point2: AbstractPoint) {\n    return point1 === point2 || (\n      point1.node === point2.node &&\n      point1.offset === point2.offset\n    );\n  }\n}\n\nexport class AbstractRange {\n  public readonly collapsed: boolean;\n  public readonly isForward: boolean;\n  constructor(\n    public readonly anchor: AbstractPoint,\n    public readonly focus: AbstractPoint,\n  ) {\n    this.collapsed = AbstractPoint.equals(anchor, focus);\n\n    const position = compareAbstractPosition(anchor.node, focus.node);\n    let forward: boolean;\n    switch (position) {\n      case AbstractPosition.Same:\n        forward = anchor.offset <= focus.offset;\n        break;\n      case AbstractPosition.Following:\n        forward = true;\n        break;\n      case AbstractPosition.Preceding:\n        forward = false;\n        break;\n      case AbstractPosition.Contains:\n        forward = focus.offset === 0;\n        break;\n      case AbstractPosition.ContainedBy:\n        forward = anchor.offset === 0;\n        break;\n      default:\n        throw new Error('Disconnect.');\n    }\n    this.isForward = forward;\n  }\n\n  static equals(range1: AbstractRange, range2: AbstractRange) {\n    return range1 === range2 || (\n      range1.collapsed === range2.collapsed &&\n      range1.isForward === range2.isForward &&\n      AbstractPoint.equals(range1.anchor, range2.anchor) &&\n      AbstractPoint.equals(range1.focus, range2.focus)\n    );\n  }\n}\n\nexport class AbstractSelection {\n  range: AbstractRange | null = null;\n  private helper: AbstractHelper;\n\n  constructor(root: AnyAbstractNode, private configs: AbstractConfigs) {\n    this.helper = new AbstractHelper(root);\n  }\n\n  private moveSelection(\n    shift: boolean,\n    forward: boolean,\n    step: number,\n  ): boolean {\n    const { range, helper, configs } = this;\n    if (!range) {\n      return false;\n    }\n    const { anchor, focus, isForward, collapsed } = range;\n    const newRange = helper.dispatchEvent<AbstractRange, SelectionMovePayload>({\n      type: AbstractEventType.SelectionMove,\n      payload: { shift, forward, step },\n    }, {\n      range,\n      forward: isForward,\n      configs,\n      point1: anchor.node,\n      point2: focus.node,\n    }) || null;\n  return this.updateRange(newRange);\n  }\n\n  forward(shift: boolean, step: number, event: KeyboardEvent) {\n    event.preventDefault();\n    return this.moveSelection(shift, true, step);\n  }\n\n  backward(shift: boolean, step: number, event: KeyboardEvent) {\n    event.preventDefault();\n    return this.moveSelection(shift, false, step);\n  }\n\n  updateRange(range: AbstractRange | null, windowSelection = window.getSelection()) {\n    if (\n      this.range !== range ||\n      !this.range ||\n      !range ||\n      !AbstractRange.equals(this.range, range)\n    ) {\n      this.range = range;\n      assert(windowSelection);\n      this.renderWindowSelection(windowSelection);\n      return true;\n    }\n    return false;\n  }\n\n  renderWindowSelection(windowSelection: Selection) {\n    const { helper } = this;\n    if (this.range) {\n      const { anchor, focus, isForward } = this.range;\n      const selection = helper.dispatchEvent<AbstractIntentTrace['windowSelection']>({\n        type: AbstractEventType.SelectionRendering,\n        payload: undefined,\n      }, {\n        range: this.range,\n        forward: isForward,\n        configs: this.configs,\n        point1: anchor.node,\n        point2: focus.node,\n      });\n\n      if (selection) {\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        assert(anchorNode && anchorOffset != null && focusNode && focusOffset != null);\n        if (\n          anchorNode !== windowSelection.anchorNode ||\n          anchorOffset !== windowSelection.anchorOffset ||\n          focusNode !== windowSelection.focusNode ||\n          focusOffset !== windowSelection.focusOffset\n        ) {\n          windowSelection.collapse(anchorNode, anchorOffset);\n          windowSelection.extend(focusNode, focusOffset);\n        }\n        return;\n      }\n    }\n\n    if (windowSelection.anchorNode || windowSelection.focusNode) {\n      windowSelection.removeAllRanges();\n    }\n  }\n\n  synchronizeWindowSelection() {\n    const windowSelection = window.getSelection();\n    assert(windowSelection);\n    const { anchorNode, anchorOffset, focusNode, focusOffset, isCollapsed } = windowSelection;\n    if (!anchorNode || !focusNode) {\n      this.updateRange(null, windowSelection);\n      return;\n    }\n\n    const anchorAbstractNode = findAbstractNodeFromDOM(anchorNode);\n    const focusAbstractNode = !anchorAbstractNode || anchorNode === focusNode\n      ? anchorAbstractNode\n      : findAbstractNodeFromDOM(focusNode);\n    if (!anchorAbstractNode || !focusAbstractNode) {\n      return;\n    }\n\n    const root = this.helper.current;\n    assert(root);\n    if (!findAbstractNode(anchorAbstractNode, root) || !findAbstractNode(focusAbstractNode, root)) {\n      return;\n    }\n\n    const position = compareAbstractPosition(anchorAbstractNode, focusAbstractNode);\n    let forward: boolean;\n    switch (position) {\n      case AbstractPosition.Same:\n        forward = anchorOffset <= focusOffset;\n        break;\n      case AbstractPosition.Following:\n        forward = true;\n        break;\n      case AbstractPosition.Preceding:\n        forward = false;\n        break;\n      case AbstractPosition.Contains:\n        forward = focusOffset === 0;\n        break;\n      case AbstractPosition.ContainedBy:\n        forward = anchorOffset === 0;\n        break;\n      default:\n        throw new Error();\n    }\n\n    const { helper } = this;\n    const newRange = helper.dispatchEvent<AbstractRange, SelectionSynchronizePayload>({\n      type: AbstractEventType.SelectionSynchronize,\n      payload: {\n        isCollapsed,\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset,\n        anchorAbstractNode,\n        focusAbstractNode,\n      },\n    }, {\n      range: this.range,\n      forward,\n      configs: this.configs,\n      point1: anchorAbstractNode,\n      point2: focusAbstractNode,\n    }) || null;\n    this.updateRange(newRange, windowSelection);\n  }\n}\n","import { isKeyHotkey } from 'is-hotkey';\n\nexport const Is_Apple = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\n\ninterface HotKeys {\n  Bold?: string | string[];\n  Compose?: string | string[];\n  MoveBackward?: string | string[];\n  MoveForward?: string | string[];\n  MoveWordBackward?: string | string[];\n  MoveWordForward?: string | string[];\n  DeleteBackward?: string | string[];\n  DeleteForward?: string | string[];\n  ExtendBackward?: string | string[];\n  ExtendForward?: string | string[];\n  Italic?: string | string[];\n  SplitBlock?: string | string[];\n  Undo?: string | string[];\n\n  MoveLineBackward?: string | string[];\n  MoveLineForward?: string | string[];\n  DeleteLineBackward?: string | string[];\n  DeleteLineForward?: string | string[];\n  DeleteWordBackward?: string | string[];\n  DeleteWordForward?: string | string[];\n  ExtendLineBackward?: string | string[];\n  ExtendLineForward?: string | string[];\n  Redo?: string | string[];\n  TransposeCharacter?: string | string[];\n}\n\nexport const GenericHotKeys: HotKeys = {\n  Bold: 'mod+b',\n  Compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  MoveBackward: 'left',\n  MoveForward: 'right',\n  MoveWordBackward: 'ctrl+left',\n  MoveWordForward: 'ctrl+right',\n  DeleteBackward: 'shift?+backspace',\n  DeleteForward: 'shift?+delete',\n  ExtendBackward: 'shift+left',\n  ExtendForward: 'shift+right',\n  Italic: 'mod+i',\n  SplitBlock: 'shift?+enter',\n  Undo: 'mod+z',\n};\n\nexport const Apple_HotKeys: HotKeys = {\n  MoveLineBackward: 'opt+up',\n  MoveLineForward: 'opt+down',\n  MoveWordBackward: 'opt+left',\n  MoveWordForward: 'opt+right',\n  DeleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  DeleteForward: ['ctrl+delete', 'ctrl+d'],\n  DeleteLineBackward: 'cmd+shift?+backspace',\n  DeleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  DeleteWordBackward: 'opt+shift?+backspace',\n  DeleteWordForward: 'opt+shift?+delete',\n  ExtendLineBackward: 'opt+shift+up',\n  ExtendLineForward: 'opt+shift+down',\n  Redo: 'cmd+shift+z',\n  TransposeCharacter: 'ctrl+t',\n};\n\nexport const Windows_HotKeys: HotKeys = {\n  DeleteWordBackward: 'ctrl+shift?+backspace',\n  DeleteWordForward: 'ctrl+shift?+delete',\n  Redo: ['ctrl+y', 'ctrl+shift+z'],\n};\n\nfunction create(key: keyof HotKeys) {\n  const generic =  GenericHotKeys[key];\n  const apple = Apple_HotKeys[key];\n  const windows = Windows_HotKeys[key];\n  const isGeneric = generic && isKeyHotkey(generic);\n  const isApple = apple && isKeyHotkey(apple);\n  const isWindows = windows && isKeyHotkey(windows);\n\n  return function isHotKey(event: KeyboardEvent) {\n    return (\n      (isGeneric && isGeneric(event)) ||\n      (Is_Apple && isApple && isApple(event)) ||\n      (!Is_Apple && isWindows && isWindows(event))\n    );\n  }\n}\n\nexport const isBold = create('Bold');\nexport const isCompose = create('Compose');\nexport const isMoveBackward = create('MoveBackward');\nexport const isMoveForward = create('MoveForward');\nexport const isDeleteBackward = create('DeleteBackward');\nexport const isDeleteForward = create('DeleteForward');\nexport const isDeleteLineBackward = create('DeleteLineBackward');\nexport const isDeleteLineForward = create('DeleteLineForward');\nexport const isDeleteWordBackward = create('DeleteWordBackward');\nexport const isDeleteWordForward = create('DeleteWordForward');\nexport const isExtendBackward = create('ExtendBackward');\nexport const isExtendForward = create('ExtendForward');\nexport const isExtendLineBackward = create('ExtendLineBackward');\nexport const isExtendLineForward = create('ExtendLineForward');\nexport const isItalic = create('Italic');\nexport const isMoveLineBackward = create('MoveLineBackward');\nexport const isMoveLineForward = create('MoveLineForward');\nexport const isMoveWordBackward = create('MoveWordBackward');\nexport const isMoveWordForward = create('MoveWordForward');\nexport const isRedo = create('Redo');\nexport const isSplitBlock = create('SplitBlock');\nexport const isTransposeCharacter = create('TransposeCharacter');\nexport const isUndo = create('Undo');\n","import React, { ReactNode, useMemo, useEffect, forwardRef } from \"react\";\nimport { AbstractSelection, AbstractRange } from \"./AbstractSelection\";\nimport { isMoveForward, isMoveBackward, isExtendForward, isExtendBackward, isBold, isItalic, isDeleteBackward, isDeleteForward, isSplitBlock } from './hotkeys';\nimport { AbstractNode, AnyAbstractNode, abstractSplice } from \"./AbstractNode\";\nimport { AbstractConfigs, AbstractEventType, SelectionMovePayload, TextQueryStylePayload, AbstractText } from \"./types\";\nimport { $, AbstractHelper } from './AbstractHelper';\nimport { assert } from \"./utils\";\nimport styles from './IntentSystem.module.css';\nimport { AbstractEvent } from \"./AbstractEvent\";\n\nfunction createCaptureCallback(interestHooks: any) {\n  return function captureCallback(this: AnyAbstractNode, event: AbstractEvent) {\n    const parentContext = event.context;\n    const currentContext = new Context(this, event, parentContext);\n    event.context = currentContext;\n    let bubble1: any;\n    let bubble2: any;\n    const value = interestHooks[this.type]\n    if (value) {\n      const { hook, browserHook } = value;\n      bubble1 = hook && hook.call(this, event);\n      bubble2 = browserHook && browserHook.call(this, event, this.state);\n    }\n\n    return function bubbleCallback(this: AnyAbstractNode) {\n      if (bubble2) {\n        bubble2.call(this);\n      }\n      if (bubble1) {\n        bubble1.call(this);\n      }\n      currentContext.replace();\n      event.context = parentContext;\n    };\n  };\n}\n\nclass Context {\n  private sliceNodes: AnyAbstractNode[] = [];\n\n  constructor(\n    private current: AnyAbstractNode,\n    private event: AbstractEvent,\n    public parentContext?: Context,\n  ) {}\n\n  peek() {\n    return this.sliceNodes.length ? this.sliceNodes[this.sliceNodes.length - 1] : undefined;\n  }\n\n  push(node: AnyAbstractNode) {\n    this.sliceNodes.push(node);\n  }\n\n  replaced = false;\n\n  replace() {\n    if (!this.replaced) {\n      this.replaced = true;\n\n      const { leftChildIndex: start, rightChildIndex: end } = this.event;\n      if (start != null && end != null) {\n        assert(start <= end);\n        abstractSplice(this.current, start, end - start + 1, this.sliceNodes);\n      }\n    }\n  }\n}\n\nexport class IntentSystem {\n  private helper: AbstractHelper;\n  private abstractSelection: AbstractSelection;\n\n  // private continuousKeyDown = 0;\n\n  constructor(root: AnyAbstractNode, private configs: AbstractConfigs) {\n    this.helper = $(root);\n    this.abstractSelection = new AbstractSelection(root, configs);\n    (window as any).sel = this.abstractSelection;\n  }\n\n  nextKeyUp(event: React.KeyboardEvent) {\n    // this.continuousKeyDown = 0;\n  }\n\n  nextKeyDown(event: React.KeyboardEvent) {\n    const { abstractSelection, configs, helper } = this;\n    const { nativeEvent } = event;\n    assert(helper.current);\n    // this.continuousKeyDown += 1;\n\n    if (isMoveForward(nativeEvent)) {\n      console.log('forward');\n      abstractSelection.forward(false, 1, nativeEvent);\n    } else if (isMoveBackward(nativeEvent)) {\n      console.log('backward');\n      abstractSelection.backward(false, 1, nativeEvent);\n    } else if (isExtendForward(nativeEvent)) {\n      console.log('extend forward');\n      abstractSelection.forward(true, 1, nativeEvent);\n    } else if (isExtendBackward(nativeEvent)) {\n      console.log('extend backward');\n      abstractSelection.backward(true, 1, nativeEvent);\n    } else if (isBold(nativeEvent) || isItalic(nativeEvent)) {\n      const formatBold = isBold(nativeEvent);\n      const formatItalic = isItalic(nativeEvent);\n\n      const keys: TextQueryStylePayload['keys'] = [];\n      if (formatBold) {\n        keys.push('fontWeight');\n        console.log('bold');\n      }\n      if (formatItalic) {\n        keys.push('fontStyle');\n        console.log('italic');\n      }\n\n      event.preventDefault();\n      const { range } = this.abstractSelection;\n      if (range) {\n        const { anchor, focus, isForward } = range;\n        const result = helper.dispatchEvent<AbstractText['data']['style'], TextQueryStylePayload>({\n          type: AbstractEventType.TextQueryStyle,\n          payload: { keys },\n        }, {\n          forward: true,\n          point1: anchor.node,\n          point2: focus.node,\n          configs: this.configs,\n        });\n        if (result) {\n          console.log(result);\n          const boldBool = result.fontWeight === undefined;\n          const italicBool = result.fontStyle === undefined;\n\n          const [left, right] = isForward ? [anchor, focus] : [focus, anchor];\n          const leftNode = $(left.node).prevSibling().current || left.node;\n          const rightNode = $(right.node).nextSibling().current || right.node;\n\n          const payload: { style: any; excludes: AnyAbstractNode[] } = {\n            style: {},\n            excludes: [],\n          };\n          if (leftNode !== left.node) {\n            payload.excludes.push(leftNode);\n          }\n          if (rightNode !== right.node) {\n            payload.excludes.push(rightNode);\n          }\n          if (formatBold) {\n            payload.style.fontWeight = boldBool ? 600 : undefined;\n          }\n          if (formatItalic) {\n            payload.style.fontStyle = italicBool ? 'italic' : undefined;\n          }\n\n          const nextRange: AbstractRange | undefined = helper.dispatchEvent({\n            type: AbstractEventType.TextFormatStyle,\n            payload,\n          }, {\n            forward: true,\n            range: range,\n            point1: leftNode,\n            point2: rightNode,\n            configs: this.configs,\n            createCaptureCallback,\n          });\n          assert(nextRange);\n          Promise.resolve().then(() => {\n            this.abstractSelection.updateRange(nextRange);\n          });\n        }\n      }\n    } else if (isDeleteBackward(nativeEvent) || isDeleteForward(nativeEvent)) {\n      const deleteForward = !!isDeleteForward(nativeEvent);\n      console.log(deleteForward ? 'delete backward' : 'delete forward');\n      nativeEvent.preventDefault();\n      const { range } = this.abstractSelection;\n      if (range) {\n        const { isForward, collapsed, anchor, focus } = range;\n        let deleteRange: AbstractRange | undefined;\n        if (collapsed) {\n          deleteRange = helper.dispatchEvent<AbstractRange, SelectionMovePayload>({\n            type: AbstractEventType.SelectionMove,\n            payload: { shift: true, forward: deleteForward, step: 1 },\n          }, {\n            range,\n            forward: isForward,\n            point1: anchor.node,\n            point2: focus.node,\n            configs: this.configs,\n          });\n        } else {\n          deleteRange = range;\n        }\n\n        if (deleteRange && !deleteRange.collapsed) {\n          const abstractRange: AbstractRange = helper.dispatchEvent({\n            type: AbstractEventType.ContentReplace,\n            payload: {\n              key: '',\n            },\n          }, {\n            range: deleteRange,\n            forward: true,\n            point1: deleteRange.anchor.node,\n            point2: deleteRange.focus.node,\n            configs,\n            originEvent: event,\n            createCaptureCallback,\n          }) as AbstractRange;\n          assert(abstractRange);\n          Promise.resolve().then(() => {\n            this.abstractSelection.updateRange(abstractRange);\n          });\n        }\n      }\n    } else if (isSplitBlock(nativeEvent)) {\n      event.preventDefault();\n      const { range } = abstractSelection;\n      if (range) {\n        const { anchor, focus, isForward } = range;\n        helper.dispatchEvent({\n          type: AbstractEventType.TextEnter,\n          payload: undefined,\n        }, {\n          range,\n          forward: true,\n          point1: anchor.node,\n          point2: focus.node,\n          configs,\n        });\n      }\n    } else if (\n      !event.metaKey && (\n        event.keyCode === 32 ||\n        (event.keyCode >= 48 && event.keyCode <= 90) ||\n        (event.keyCode >= 186 && event.keyCode <= 223)\n      )\n    ) {\n      console.log(event.key);\n      const { range } = abstractSelection;\n      if (range) {\n        const { anchor, focus, isForward } = range;\n        event.preventDefault();\n        const abstractRange: AbstractRange = helper.dispatchEvent({\n          type: AbstractEventType.ContentReplace,\n          payload: {\n            key: event.key,\n          },\n        }, {\n          range,\n          forward: true,\n          point1: anchor.node,\n          point2: focus.node,\n          configs,\n          originEvent: event,\n          createCaptureCallback,\n        }) as AbstractRange;\n        assert(abstractRange);\n        Promise.resolve().then(() => {\n          this.abstractSelection.updateRange(abstractRange);\n        });\n      }\n    }\n  }\n\n  nextSelectionChange() {\n    this.abstractSelection.synchronizeWindowSelection();\n  }\n}\n\ninterface IntentProps {\n  editable: boolean;\n  root: AnyAbstractNode;\n  configs: AbstractConfigs;\n  children?: ReactNode;\n}\n\nfunction useIntentSystem(root: AnyAbstractNode, configs: AbstractConfigs) {\n  return useMemo(() => {\n    const intentSystem = new IntentSystem(root, configs);\n    return {\n      nextKeyDown: intentSystem.nextKeyDown.bind(intentSystem),\n      nextKeyUp: intentSystem.nextKeyUp.bind(intentSystem),\n      nextSelectionChange: intentSystem.nextSelectionChange.bind(intentSystem),\n    };\n  }, [configs, root]);\n}\n\nexport function UserIntention({ editable, root, configs, children }: IntentProps) {\n  const {\n    nextKeyDown,\n    nextKeyUp,\n    nextSelectionChange,\n  } = useIntentSystem(root, configs);\n\n  useEffect(() => {\n    document.addEventListener('selectionchange', nextSelectionChange);\n    return () => {\n      document.removeEventListener('selectionchange', nextSelectionChange);\n    };\n  }, [nextSelectionChange]);\n\n  return (\n    <div\n      className={styles.editable}\n      spellCheck={false}\n      tabIndex={0}\n      contentEditable={editable}\n      suppressContentEditableWarning\n      onKeyDown={nextKeyDown}\n      onKeyUp={nextKeyUp}\n    >\n      {children}\n    </div>\n  );\n}\n","import React, { useMemo, createContext } from \"react\";\nimport { DocType, DocConfigs } from \"../types\";\nimport { AbstractNode, AnyAbstractNode } from \"../AbstractNode\";\n\ninterface DocumentContext {\n  configs: DocConfigs;\n}\n\nconst EmptyDocConfig = {\n  View: function EmptyView() {\n    return null;\n  },\n};\n\nexport const documentContext = createContext<DocumentContext>({\n  configs: {\n    [DocType.Doc]: EmptyDocConfig,\n    [DocType.List]: EmptyDocConfig,\n    [DocType.ListItem]: EmptyDocConfig,\n    [DocType.Paragraph]: EmptyDocConfig,\n    [DocType.Text]: EmptyDocConfig,\n  },\n});\n\ninterface DocumentProps {\n  root: AnyAbstractNode;\n  configs: DocConfigs;\n}\n\nexport function EditorDocument({\n  root,\n  configs,\n}: DocumentProps) {\n  const value = useMemo<DocumentContext>(() => ({\n    configs,\n  }), [configs]);\n  const type = root.type;\n  const RootView = configs[type].View;\n\n  return (\n    <documentContext.Provider value={value}>\n      <RootView key={root.id} context={root}  />\n    </documentContext.Provider>\n  );\n}\n","import React, { useRef, useEffect, useContext, useState, useMemo, useLayoutEffect } from 'react';\nimport { AbstractNode, AnyAbstractNode } from '../AbstractNode';\nimport { documentContext } from './EditorDocument';\nimport { DocType } from '../types';\n\nexport function useConnectAbstractNode<T extends Element>(abstractNode: AnyAbstractNode) {\n  const ref = useRef<T>(null);\n  useLayoutEffect(() => {\n    if (ref.current) {\n      (ref.current as any).__ABSTRACT__ = abstractNode;\n    }\n  }, [abstractNode]);\n  return ref;\n}\n\nexport function useNextDocViews(context: AnyAbstractNode) {\n  const { configs: docConfigs } = useContext(documentContext);\n  const [abstractNodes, setAbstractNodes] = useState(context.abstractNodes);\n  useLayoutEffect(() => {\n    context.renderAbstractNodes = setAbstractNodes;\n    return () => {\n      context.renderAbstractNodes = undefined;\n    };\n  }, [context]);\n  return useMemo(() => {\n    if (!abstractNodes) {\n      return null;\n    }\n    return abstractNodes.map(node => {\n      const { View } = docConfigs[node.type];\n      return <View key={node.id} context={node} />;\n    });\n  }, [abstractNodes, docConfigs]);\n}\n\nexport function useAbstractNodeData<T extends AnyAbstractNode>(abstractNode: T) {\n  const [data, setData] = useState<T['data']>(abstractNode.data);\n  useLayoutEffect(() => {\n    abstractNode.render = setData;\n    return () => {\n      abstractNode.render = undefined;\n    }\n  }, [abstractNode]);\n  return data;\n}\n\nexport function useViewState<T extends AnyAbstractNode>(node: T, viewData: AnyAbstractNode['state']) {\n  useLayoutEffect(() => {\n    node.state = viewData;\n    return () => {\n      node.state = undefined;\n    };\n  }, [node, viewData]);\n}\n","import React, { useMemo } from 'react';\nimport { AbstractNode } from \"../AbstractNode\";\nimport { AbstractEventType, SelectionSynchronizePayload, DocType, AbstractDoc, AbstractBrowserHooks } from \"../types\";\nimport { useNextDocViews, useConnectAbstractNode, useViewState } from \"./hooks\";\nimport { AbstractEvent, AbstractIntentTrace } from '../AbstractEvent';\nimport { AbstractRange, AbstractPoint } from '../AbstractSelection';\n\nfunction selectionSynchronize(event: AbstractEvent<SelectionSynchronizePayload, AbstractRange>) {\n  return function bubbleDocSyncSelection() {\n    const selection = event.trace.selection;\n    if (selection && selection.anchorPoint && selection.focusPoint) {\n      event.returnValue = new AbstractRange(\n        selection.anchorPoint,\n        selection.focusPoint,\n      );\n    }\n  };\n}\n\nfunction selectionRendering(event: AbstractEvent<any, AbstractIntentTrace['windowSelection']>) {\n  return function bubbleSelectionRendering() {\n    const windowSelection = event.trace.windowSelection;\n    if (\n      windowSelection &&\n      windowSelection.anchorNode &&\n      windowSelection.anchorOffset != null &&\n      windowSelection.focusNode &&\n      windowSelection.focusOffset != null\n    ) {\n      event.returnValue = windowSelection;\n    }\n  };\n}\n\nexport function DocView({ context }: { context: AbstractDoc }) {\n  const ref = useConnectAbstractNode<HTMLDivElement>(context);\n  return <div ref={ref}>{useNextDocViews(context)}</div>;\n}\n\nconst browserHooks: AbstractBrowserHooks = {\n  [AbstractEventType.SelectionSynchronize]: selectionSynchronize,\n  [AbstractEventType.SelectionRendering]: selectionRendering,\n};\n\nexport const DocConfig = {\n  View: DocView,\n  hooks: {},\n  browserHooks,\n};\n","\nimport React, { useMemo } from 'react';\nimport { AbstractNode } from \"../AbstractNode\";\nimport { AbstractEventType, SelectionSynchronizePayload, DocType, AbstractParagraph, AbstractBrowserHooks, EditorConfigs } from \"../types\";\nimport { useNextDocViews, useAbstractNodeData, useConnectAbstractNode, useViewState } from \"./hooks\";\nimport { AbstractEvent } from '../AbstractEvent';\nimport { assert } from '../utils';\n\nfunction paragraphSyncSelection(\n  this: AbstractParagraph,\n  event: AbstractEvent<SelectionSynchronizePayload, AbstractRange>,\n) {\n  const { payload } = event;\n  if (payload.anchorAbstractNode === this || payload.focusAbstractNode === this) {\n    // TODO\n  }\n}\n\nexport function ParagraphView({ context }: { context: AbstractParagraph }) {\n  const ref = useConnectAbstractNode<HTMLDivElement>(context);\n  const data = useAbstractNodeData(context);\n  const views = useNextDocViews(context);\n  return (\n    <div ref={ref} style={{ textAlign: data && data.align }}>\n      {views}\n    </div>\n  );\n}\n\nconst browserHooks: AbstractBrowserHooks = {\n  [AbstractEventType.SelectionSynchronize]: paragraphSyncSelection,\n};\n\nfunction contentReplace(\n  this: AbstractParagraph,\n  event: AbstractEvent,\n) {\n  const { context } = event;\n  return function bubble(this: AbstractParagraph) {\n    assert(context);\n    context.replace();\n    if (this.abstractNodes) {\n      context.parentContext.push(this);\n    }\n  };\n}\n\nfunction textFormatStyle(\n  this: AbstractParagraph,\n  event: AbstractEvent,\n) {\n  const { context } = event;\n  return function bubble(this: AbstractParagraph) {\n    assert(context);\n    context.replace();\n    if (this.abstractNodes) {\n      context.parentContext.push(this);\n    }\n  };\n}\n\nexport const paragraphConfig: EditorConfigs[DocType.Paragraph] = {\n  View: ParagraphView,\n  hooks: {\n    [AbstractEventType.ContentReplace]: contentReplace,\n    [AbstractEventType.TextFormatStyle]: textFormatStyle,\n  },\n  browserHooks,\n};\n","import React, { useMemo, forwardRef, useEffect, useLayoutEffect } from 'react';\nimport { AbstractNode, abstractUpdate, AnyAbstractNode } from \"../AbstractNode\";\nimport { AbstractEventType, Reference, SelectionSynchronizePayload, DocType, AbstractText, SelectionMovePayload, SelectionTryMovePayload, AbstractHooks, AbstractBrowserHooks, TextQueryStylePayload } from \"../types\";\nimport { useAbstractNodeData, useConnectAbstractNode, useViewState } from \"./hooks\";\nimport { AbstractEvent } from '../AbstractEvent';\nimport { AbstractPoint, AbstractRange } from '../AbstractSelection';\nimport { $ } from '../AbstractHelper';\nimport { assert, isPartialShallowEqual, randomId, pick } from '../utils';\n\nexport function createAbstractText({\n  id = randomId(),\n  data,\n  parent,\n}: {\n  id?: string;\n  data: AbstractText['data'];\n  parent?: AnyAbstractNode;\n}): AbstractText {\n  return {\n    type: DocType.Text,\n    id,\n    data,\n    parent,\n  };\n}\n\nexport function isSameStyleText({ data: { style: style1 } }: AbstractText, { data: { style: style2 } }: AbstractText) {\n  if (!style1 && !style2) {\n    return true;\n  }\n  return (\n    style1?.color === style2?.color &&\n    style1?.fontFamily === style2?.fontFamily &&\n    style1?.fontSize === style2?.fontSize &&\n    style1?.fontStyle === style2?.fontStyle &&\n    style1?.fontWeight === style2?.fontWeight &&\n    style1?.textDecoration === style2?.textDecoration\n  );\n}\n\n// function tryMergeText(leftText: AbstractText, rightText: AbstractText, forward: boolean): AbstractText | [AbstractText, AbstractText] {\n//   const style1 = leftText.data.style;\n//   const style2 = rightText.data.style;\n//   if (isPartialShallowEqual(style1, style2, true)) { // incorrect shallow equal\n//     return createAbstractText({\n//       content: leftText.data.content + rightText.data.content,\n//       style: style1,\n//     });\n//   }\n//   return [leftText, rightText];\n// }\n\nfunction selectionSynchronize(\n  this: AbstractText,\n  event: AbstractEvent<SelectionSynchronizePayload, AbstractRange>,\n) {\n  const { ref } = this.state;\n  const { payload } = event;\n  if (payload.anchorAbstractNode === this || payload.focusAbstractNode === this) {\n    const textNode = ref.current?.firstChild;\n    if (textNode) {\n      const trace = event.trace.selection || { anchorPoint: undefined, focusPoint: undefined };\n      event.trace.selection = trace;\n      if (payload.anchorNode === textNode) {\n        trace.anchorPoint = new AbstractPoint(this, payload.anchorOffset);\n      }\n      if (payload.focusNode === textNode) {\n        trace.focusPoint = new AbstractPoint(this, payload.focusOffset);\n      }\n    }\n  }\n}\n\nfunction selectionRendering(\n  this: AbstractText,\n  event: AbstractEvent<undefined, Range>,\n) {\n  const { ref } = this.state;\n  const { range } = event;\n  assert(range);\n  if (range.anchor.node === this || range.focus.node === this) {\n    const textNode = ref.current?.firstChild;\n    if (textNode) {\n      const trace = event.trace.windowSelection || {\n        anchorNode: undefined,\n        anchorOffset: undefined,\n        focusNode: undefined,\n        focusOffset: undefined,\n      };\n      event.trace.windowSelection = trace;\n      if (range.anchor.node === this) {\n        trace.anchorNode = textNode;\n        trace.anchorOffset = range.anchor.offset;\n      }\n      if (range.focus.node === this) {\n        trace.focusNode = textNode;\n        trace.focusOffset = range.focus.offset;\n      }\n    }\n  }\n}\n\nfunction _TextView({ context }: { context: AbstractText }) {\n  const { content, style } = useAbstractNodeData(context);\n  const ref = useConnectAbstractNode<HTMLSpanElement>(context);\n\n  const viewData = useMemo(() => ({ ref }), [ref]);\n  useViewState(context, viewData);\n\n  return (\n    <span ref={ref} style={style}>\n      {content.replace(/ /g, '\\u00a0')}\n    </span>\n  );\n}\n_TextView.displayName = 'TextView';\nconst TextView = React.memo(_TextView, () => true);\n\nfunction selectionMove(\n  this: AbstractText,\n  event: AbstractEvent<SelectionMovePayload, AbstractRange, React.KeyboardEvent>,\n) {\n  assert(event.range);\n  const { anchor, focus, isForward, collapsed } = event.range;\n  const { forward, shift, step } = event.payload;\n  if (focus.node === this) {\n    let finalFocus: AbstractPoint;\n    if (!shift && !collapsed) {\n      let point = forward === isForward ? focus : anchor;\n      if (!forward && point.offset === 0) {\n        const result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n          type: AbstractEventType.SelectionTryMove,\n          payload: {\n            step: 0,\n            forward: false,\n          },\n        }, {\n          initiator: point.node,\n          point1: point.node,\n          forward: false,\n          configs: event.configs,\n        });\n        if (result) {\n          point = result;\n        }\n      }\n      event.returnValue = new AbstractRange(point, point);\n      return;\n    }\n\n    if (forward) {\n      const remain = this.data.content.length - focus.offset - step;\n      if (remain >= 0) {\n        finalFocus = new AbstractPoint(this, focus.offset + step);\n      } else {\n        const result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n          type: AbstractEventType.SelectionTryMove,\n          payload: {\n            step: -remain,\n            forward: true,\n          },\n        }, {\n          initiator: this,\n          point1: this,\n          forward: true,\n          configs: event.configs,\n        });\n        finalFocus = result || new AbstractPoint(this, this.data.content.length);\n      }\n    } else {\n      const remain = focus.offset - step;\n      if (remain > 0 || (shift && remain === 0)) {\n        finalFocus = new AbstractPoint(this, remain);\n      } else {\n        const result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n          type: AbstractEventType.SelectionTryMove,\n          payload: {\n            step: -remain,\n            forward: false,\n          },\n        }, {\n          initiator: this,\n          point1: this,\n          forward: false,\n          configs: event.configs,\n        });\n        finalFocus = result || new AbstractPoint(this, 0);\n      }\n    }\n\n    let finalAnchor = shift ? anchor : finalFocus;\n    if (shift) {\n      if (forward ? anchor.offset === anchor.node.data.content.length : anchor.offset === 0) {\n        const result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n          type: AbstractEventType.SelectionTryMove,\n          payload: {\n            step: 0,\n            forward,\n          },\n        }, {\n          initiator: anchor.node,\n          point1: anchor.node,\n          forward,\n          configs: event.configs,\n        });\n        if (result) {\n          finalAnchor = result;\n        }\n      }\n    }\n\n    console.log(finalAnchor, finalFocus)\n    event.returnValue = new AbstractRange(finalAnchor, finalFocus);\n  }\n}\n\nfunction selectionTryMove(\n  this: AbstractText,\n  event: AbstractEvent<SelectionTryMovePayload>,\n) {\n  const { payload: { forward, step }, initiator } = event;\n  assert(initiator);\n  if (this === initiator) {\n    event.stopPropagation();\n    return;\n  }\n  event.payload.step = Math.max(0, step - this.data.content.length);\n  if (event.payload.step === 0) {\n    event.returnValue = new AbstractPoint(this, forward ? step : this.data.content.length - step);\n    event.bail();\n  }\n}\n\nfunction contentReplace(\n  this: AbstractText,\n  event: AbstractEvent,\n) {\n  assert(event.range);\n  const { anchor, focus, isForward } = event.range;\n  const anchorBool = anchor.node === this;\n  const focusBool = focus.node === this;\n\n  if (anchorBool || focusBool) {\n    const { content } = this.data;\n  \n    let spliceStart: number;\n    let spliceEnd: number;\n    if (isForward) {\n      spliceStart = anchorBool ? anchor.offset : 0;\n      spliceEnd = focusBool ? focus.offset : content.length;\n    } else {\n      spliceStart = anchorBool && !focusBool ? 0 : focus.offset;\n      spliceEnd = focusBool && !anchorBool ? content.length : anchor.offset;\n    }\n  \n    assert(spliceStart <= spliceEnd);\n    const willFocus = isForward ? anchorBool : focusBool;\n    const value = willFocus ? event.payload.key : '';\n    const array = Array.from(content);\n    array.splice(spliceStart, spliceEnd - spliceStart, value);\n    const nextContent = array.join('');\n    abstractUpdate(this, ({ style }) => ({\n      content: nextContent,\n      style,\n    }));\n    \n    const context = event.context;\n    if (context && nextContent) {\n      context.parentContext.push(this);\n      if (willFocus) {\n        let point = new AbstractPoint(this, spliceStart + value.length);\n        if (point.offset === 0) {\n          const result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n            type: AbstractEventType.SelectionTryMove,\n            payload: {\n              step: 0,\n              forward: false,\n            },\n          }, {\n            initiator: this,\n            point1: this,\n            forward: false,\n            configs: event.configs,\n          });\n          if (result) {\n            point = result;\n          }\n        }\n        event.returnValue = new AbstractRange(point, point);\n      }\n    } else if (willFocus) {\n      let result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n        type: AbstractEventType.SelectionTryMove,\n        payload: {\n          step: 0,\n          forward: false,\n        },\n      }, {\n        initiator: this,\n        point1: this,\n        forward: false,\n        configs: event.configs,\n      });\n      if (!result) {\n        result = $(event.root).dispatchEvent<AbstractPoint, SelectionTryMovePayload>({\n          type: AbstractEventType.SelectionTryMove,\n          payload: {\n            step: 0,\n            forward: true,\n          },\n        }, {\n          initiator: this,\n          point1: this,\n          forward: true,\n          configs: event.configs,\n        });\n      }\n      assert(result);\n      event.returnValue = new AbstractRange(result, result);\n    }\n  }\n}\n\nfunction textEnter(\n  this: AbstractText,\n  event: AbstractEvent,\n) {\n  console.log('enter')\n}\n\nfunction textQueryStyle(\n  this: AbstractText,\n  event: AbstractEvent<TextQueryStylePayload, AbstractText['data']['style']>,\n) {\n  const { style } = this.data;\n  const { payload } = event;\n\n  if (!style) {\n    event.returnValue = {};\n    event.bail();\n    return;\n  }\n\n  if (event.returnValue === undefined) {\n    event.returnValue = pick(style, payload.keys, true);\n    payload.keys = Object.keys(event.returnValue) as TextQueryStylePayload['keys'];\n  }\n\n  const { returnValue } = event;\n  const { keys } = payload;\n  let requireClean = false;\n  for (const key of keys) {\n    if (style[key] !== returnValue[key]) {\n      returnValue[key] = undefined;\n      if (!requireClean) {\n        requireClean = true;\n      }\n    }\n  }\n\n  if (requireClean) {\n    event.returnValue = pick(returnValue, keys, true);\n    payload.keys = Object.keys(event.returnValue) as TextQueryStylePayload['keys'];\n    if (!payload.keys.length) {\n      event.bail();\n    }\n  }\n}\n\nfunction pushText({ parentContext }: any, data: AbstractText['data'], parent?: AnyAbstractNode, absText = createAbstractText({ data, parent })) {\n  assert(parentContext);\n  const lastNode: AnyAbstractNode | undefined = parentContext.peek();\n  abstractUpdate(absText, data);\n  if (\n    !lastNode ||\n    lastNode.type !== DocType.Text ||\n    !isSameStyleText(lastNode as AbstractText, absText)\n  ) {\n    parentContext.push(absText);\n    return absText;\n  } else {\n    abstractUpdate(lastNode as AbstractText, prev => ({\n      content: prev.content + data.content,\n      style: prev.style,\n    }));\n    return lastNode;\n  }\n}\n\nfunction textFormatStyle(\n  this: AbstractText,\n  event: AbstractEvent,\n) {\n  const { data: { content, style } } = this;\n  const { payload, context, range } = event;\n  assert(context && range);\n  const { anchor, focus, isForward } = range;\n\n  let leftContent: string | undefined;\n  let rightContent: string | undefined;\n  let left: AbstractPoint | undefined;\n  let right: AbstractPoint | undefined;\n  if (!range.collapsed && (anchor.node === this || focus.node === this)) {\n    const _anchor = anchor.node === this ? anchor : undefined;\n    const _focus = focus.node === this ? focus : undefined;\n    [left, right] = isForward ? [_anchor, _focus] : [_focus, _anchor];\n    if (left && left.offset > 0) {\n      leftContent = content.slice(0, left.offset);\n    }\n    if (right && right.offset < content.length) {\n      rightContent = content.slice(right.offset);\n    }\n  }\n  const formatContent = !leftContent && !rightContent ? content : content.slice(left?.offset, right?.offset);\n\n  if (leftContent) {\n    pushText(context, {\n      content: leftContent,\n      style,\n    }, this.parent);\n  }\n  const formatedData = payload.excludes.indexOf(this) !== -1 ? this.data : {\n    content: formatContent,\n    style: {\n      ...style,\n      ...payload.style,\n    },\n  };\n  const formatedText = pushText(context, formatedData, this.parent, this);\n  const rightText = rightContent ? pushText(context, { content: rightContent, style }, this.parent) : undefined;\n\n  if (left || right) {\n    const abstractRange = event.returnValue;\n    const leftPoint = (\n      left &&\n      new AbstractPoint(formatedText, formatedText.data.content.length - formatContent.length)\n    );\n    const rightPoint = (\n      right &&\n      new AbstractPoint(formatedText, formatedText.data.content.length - (rightText === formatedText ? rightContent!.length : 0))\n    );\n    let p1: AbstractPoint;\n    let p2: AbstractPoint;\n    if (isForward) {\n      p1 = leftPoint || abstractRange?.anchor || rightPoint;\n      p2 = rightPoint || abstractRange?.focus || leftPoint;\n    } else {\n      p1 = rightPoint || abstractRange?.anchor || leftPoint;\n      p2 = leftPoint || abstractRange?.focus || rightPoint;\n    }\n    event.returnValue = new AbstractRange(p1, p2);\n  }\n}\n\nconst hooks: AbstractHooks = {\n  [AbstractEventType.SelectionMove]: selectionMove,\n  [AbstractEventType.SelectionTryMove]: selectionTryMove,\n  [AbstractEventType.ContentReplace]: contentReplace,\n  [AbstractEventType.TextEnter]: textEnter,\n  [AbstractEventType.TextQueryStyle]: textQueryStyle,\n  [AbstractEventType.TextFormatStyle]: textFormatStyle,\n};\n\nconst browserHooks: AbstractBrowserHooks = {\n  [AbstractEventType.SelectionSynchronize]: selectionSynchronize,\n  [AbstractEventType.SelectionRendering]: selectionRendering,\n};\n\nexport const TextConfig = {\n  View: TextView,\n  hooks,\n  browserHooks,\n};\n","import { EditorConfigs, DocType, AbstractDoc, AbstractParagraph, AbstractText } from \"./types\";\nimport { randomId } from \"./utils\";\nimport { ListView } from \"./DocViews\";\nimport { DocView, DocConfig } from \"./docs/Doc\";\nimport { ListItemView } from \"./docs/ListItem\";\nimport { ParagraphView, paragraphConfig } from \"./docs/Paragraph\";\nimport { TextConfig, createAbstractText } from \"./docs/Text\";\nimport { linkAbstractNode } from \"./AbstractNode\";\n\nexport const defaultEditorConfigs: EditorConfigs = {\n  [DocType.Doc]: DocConfig,\n  [DocType.List]: {\n    View: ListView,\n    hooks: {},\n    browserHooks: {},\n  },\n  [DocType.ListItem]: {\n    View: ListItemView,\n    hooks: {},\n    browserHooks: {},\n  },\n  [DocType.Paragraph]: paragraphConfig,\n  [DocType.Text]: TextConfig,\n};\n\n// const text1: AbstractText = {\n//   type: DocType.Text,\n//   id: randomId(),\n//   data: {\n//     content: '0123456789',\n//     style: {\n//       color: 'darkred',\n//       fontSize: 60,\n//     },\n//   },\n// };\n\n// const text2: AbstractText = {\n//   type: DocType.Text,\n//   id: randomId(),\n//   data: {\n//     content: '0123456789',\n//     style: {\n//       color: 'red',\n//       fontSize: 80,\n//     }\n//   },\n// };\n\n// const text3: AbstractText = {\n//   type: DocType.Text,\n//   id: randomId(),\n//   data: {\n//     content: '0123456789',\n//     style: {\n//       color: 'green',\n//       fontSize: 70,\n//     }\n//   },\n// };\n\nconst text1 = createAbstractText({\n  data: {\n    content: '0123456789',\n    style: {\n      color: 'darkred',\n      fontSize: 60,\n    },\n  },\n});\nconst text2 = createAbstractText({\n  data: {\n    content: '0123456789',\n    style: {\n      color: 'red',\n      fontSize: 80,\n    },\n  },\n});\nconst text3 = createAbstractText({\n  data: {\n    content: '0123456789',\n    style: {\n      color: 'green',\n      fontSize: 70,\n    },\n  },\n});\n\nconst texts: any[] = [];\nconst query = new URLSearchParams(document.location.search);\nconst len = +(query.get('size') || 0) / 2;\nfor (let i = 0; i < len; i++) {\n  texts.push(createAbstractText({\n    data: {\n      content: '0123456789',\n      style: {\n        color: 'red',\n        fontSize: 80,\n      },\n    },\n  }));\n  texts.push(createAbstractText({\n    data: {\n      content: '0123456789',\n      style: {\n        color: 'green',\n        fontSize: 70,\n      },\n    },\n  }));\n}\nif (query.get('log') !== 'true') {\n  (window.console as any)._log = window.console.log;\n  window.console.log = () => {};\n}\n\nconst paragraph: AbstractParagraph = {\n  type: DocType.Paragraph,\n  id: randomId(),\n  data: undefined,\n  abstractNodes: [text1, text2, text3, ...texts],\n};\n\nconst defaultAbstractNode: AbstractDoc = {\n  type: DocType.Doc,\n  id: randomId(),\n  data: undefined,\n  abstractNodes: [paragraph],\n};\n\nlinkAbstractNode(defaultAbstractNode);\n\nexport {\n  defaultAbstractNode,\n};\n\n// export const defaultDoc = {\n//   type: DocType.Doc,\n//   id: randomId(),\n//   childNodes: [\n//     {\n//       type: DocType.List,\n//       id: randomId(),\n//       childNodes: [\n//         {\n//           type: DocType.ListItem,\n//           id: randomId(),\n//           order: '1',\n//           fontSize: 30,\n//           childNodes: [\n//             { type: DocType.Paragraph, id: randomId(), childNodes: [\n//               { type: DocType.Text, id: randomId(), content: 'I am a long long long long long long long line.', style: { fontFamily: 'initial' } },\n//             ] },\n//           ],\n//         },\n//         {\n//           type: DocType.ListItem,\n//           id: randomId(),\n//           order: '2',\n//           align: 'center',\n//           childNodes: [\n//             { type: DocType.Paragraph, id: randomId(), childNodes: [\n//               { type: DocType.Text, id: randomId(), content: 'I AM Center.', style: { color: 'red' } },\n//             ] },\n//           ],\n//         },\n//         {\n//           type: DocType.ListItem,\n//           id: randomId(),\n//           order: '3',\n//           align: 'right',\n//           childNodes: [\n//             { type: DocType.Paragraph, id: randomId(), childNodes: [\n//               { type: DocType.Text, id: randomId(), content: 'I AM OOOOOOOOPS', style: { textDecoration: 'underline wavy' } },\n//             ] },\n//           ],\n//         },\n//         {\n//           type: DocType.Paragraph,\n//           id: randomId(),\n//           align: 'center',\n//           childNodes: [\n//             { type: DocType.Text, id: randomId(), content: 'I ', style: { fontFamily: 'initial', fontSize: 30 } },\n//             { type: DocType.Text, id: randomId(), content: 'am ', style: { fontFamily: 'cursive' } },\n//             { type: DocType.Text, id: randomId(), content: 'a ', style: { color: 'red' } },\n//             { type: DocType.Text, id: randomId(), content: 'cute ', style: { textDecoration: 'underline wavy' } },\n//             { type: DocType.Text, id: randomId(), content: 'editor.', style: { fontStyle: 'italic' } },\n//           ],\n//         },\n//       ],\n//       orderList: true,\n//     },\n//     {\n//       type: DocType.Paragraph,\n//       id: randomId(),\n//       childNodes: [\n//         { type: DocType.Text, id: randomId(), content: 'I ', style: { fontFamily: 'initial', fontSize: 30 } },\n//         { type: DocType.Text, id: randomId(), content: 'am ', style: { fontFamily: 'cursive' } },\n//         { type: DocType.Text, id: randomId(), content: 'a ', style: { color: 'red' } },\n//         { type: DocType.Text, id: randomId(), content: 'cute ', style: { textDecoration: 'underline wavy' } },\n//         { type: DocType.Text, id: randomId(), content: 'editor.', style: { fontStyle: 'italic' } },\n//       ],\n//     },\n//   ],\n// };\n","import React, { useContext, useMemo, useState } from 'react';\nimport { AbstractNode, AnyAbstractNode } from './AbstractNode';\nimport { documentContext } from './docs/EditorDocument';\nimport { DocType, AbstractList } from './types';\n\nfunction useNextDocViews(context: AnyAbstractNode) {\n  const { configs: docConfigs } = useContext(documentContext);\n  const [nodes, setNodes] = useState(context.abstractNodes);\n  context.renderAbstractNodes = setNodes;\n  return useMemo(() => {\n    if (!nodes) {\n      return null;\n    }\n    return nodes.map(node => {\n      const { View } = docConfigs[node.type];\n      return <View key={node.id} context={node as any} />;\n    });\n  }, [nodes, docConfigs]);\n}\n\nexport function ListView({ context }: { context: AbstractList }) {\n  const views = useNextDocViews(context);\n  return <div>{views}</div>;\n}\n","import React from 'react';\nimport { AbstractNode } from \"../AbstractNode\";\nimport { DocType, AbstractListItem } from \"../types\";\nimport { useNextDocViews, useAbstractNodeData } from \"./hooks\";\n\nexport function ListItemView({ context }: { context: AbstractListItem }) {\n  const { order } = useAbstractNodeData(context);\n  const views = useNextDocViews(context);\n  return (\n    <div style={{ display: 'flex' }}>\n      <div\n        style={{\n          display: 'flex',\n          flexDirection: 'row',\n          alignItems: 'baseline',\n        }}\n      >\n        <div contentEditable={false} style={{ userSelect: 'none', paddingRight: 5 }}>{order}.</div>\n        {views}\n      </div>\n    </div>\n  );\n}\n","import React, { useMemo } from 'react';\nimport { UserIntention } from './IntentSystem';\nimport { EditorConfigs, DocType } from './types';\nimport { AbstractNode, AnyAbstractNode } from './AbstractNode';\nimport { defaultEditorConfigs, defaultAbstractNode } from './defaultConfigs';\nimport { EditorDocument } from './docs/EditorDocument';\n\ninterface EditorProps {\n  editable?: boolean;\n  abstractNode?: AnyAbstractNode;\n  configs?: EditorConfigs;\n}\n\nexport function Editor({\n  editable = true,\n  abstractNode = defaultAbstractNode,\n  configs = defaultEditorConfigs,\n}: EditorProps) {\n  (window as any).root = abstractNode;\n  return (\n    <UserIntention editable={editable} root={abstractNode} configs={configs}>\n      <EditorDocument root={abstractNode} configs={configs} />\n    </UserIntention>\n  );\n}\n","import React, { useEffect, useState } from 'react';\nimport { Editor } from './editor/Editor';\nimport './App.css';\n\nfunction App() {\n  const [editor, setEditor] = useState<JSX.Element | null>(null);\n  useEffect(() => {\n    setTimeout(() => {\n      setEditor(<Editor />);\n    }, 200);\n  }, []);\n\n  return editor;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}